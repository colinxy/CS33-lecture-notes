#+TITLE: Lecture 8
#+DATE: <2016-04-27 Wed>
#+OPTIONS: author:nil


* TODO Memory Layout
try memory layout example

 - stack
   - runtime stack (8MB limit)
 - heap
   - dynamically allocated
   - =malloc=, =calloc=, =new=
 - data
   - statically allocated data
   - e.g. global variables, =static= variables, string constants
 - text / shared library
   - executable machine instructions
   - read-only


#+ATTR_HTML: :width 100px
#+ATTR_LATEX: :width 100px
[[./res/memory_layout.png]]


* TODO Buffer Overflow

*** String Library Code

#+BEGIN_SRC C

  char *gets(char *dest) {
    int c = getchar();
    char *p = dest;
    while (c != EOF && c != '\n') {
      *p++ = c;
      c = getchar();
    }
    *p = '\0';
    return dest;
  }

#+END_SRC

 - library implementation of unix function =gets()=
   - no way to specify limit on number of characters to read


** Avoid Overflow Vulnerabilities in Code


** Return-Oriented Programming Attacks


#+BEGIN_COMMENT

#+BEGIN_SRC C

  typedef struct {
    int a[2];
    double d;
  } struct_t;

  double fun(int i) {
    volatile struct_t s;
    s.d = 3.14;
    s.a[i] = 1073741824;
    return s.d;
  }

#+END_SRC

#+END_COMMENT

* Float

** Fractional Binary Numbers

#+ATTR_HTML: :width 500px
[[./res/fractional_binary_number.png]]

 - bits to right of 'binary point' represent fractional powers of 2
 - representation of rational numbers
   $$ \sum_{k=-j}^{i} b_k \times 2^k $$

*** example

#+BEGIN_EXAMPLE

value     |   representation
----------------------------
5 + 3/4   ==>  101.11
2 + 7/8   ==>   10.111
1 + 7/16  ==>    1.0111

#+END_EXAMPLE

 - observations
   - divide by 2 by shifting right (unsigned)
   - multiply by 2 by shifting left
   - number of the form 0.11111_{2} are just below 1.0
     - \( \sum \frac{1}{2^i} \) goes to 1.0
     - use notation 1.0 - \epsilon

*** limitations

 - can only reprsent numbers of the form x/2^{k}
   - other rational numbers have repeating bit representations
 - just 1 setting of binary point within w bits
   - limited range of numbers


** Floating Point Representation (IEEE Standard 754)

 - numerical form \[ (-1)^{s} M 2^{E} \]
   - sign bit    =s=, determines whether number is negative or positive
     - most significant bit is sign bit =s=
   - exponent    =E=, weights value by power of 2
     - exp field encodes E (*but is not equal to E*)
   - significand =M=, is normally a fractional value \( 1.0 \leq x < 2.0 \)
     - frac field encodes M (*but is not equal to M*)

#+ATTR_HTML: :width 500px
[[./res/single_precision.png]]

#+ATTR_HTML: :width 500px
[[./res/double_precision.png]]


** Normalized Values

 - when exp \neq 00...0 and exp \neq 11...1

 - exponent coded as a biased value: E = Exp - Bias
   - Exp: unsigned value of exp field
   - Bias = 2^{k-1} - 1, where k is number of exponent bits
     - single precision: Bias = 127
       - Exp: 1~254, E: -126~127
     - double precision: Bias = 1023
       - Exp: 1~2046, E: -1022~1023

 - significand coded with implied leading 1: M = 1.xxx...x_{2}
   - xxx...x: bits of frac field
   - minimal when frac = 000...0
     - M = 1.0
   - maximal when frac = 111...1
     - M = 2.0 - \epsilon
 - get extra leading bit for free

*** example

15213_{10}

 - as an integer 11101101101101_{2}
 - as a float 1.1101101101101_{2} \times 2^{13}
   - significand
     - =M= = 1.1101101101101_{2}
     - =frac= = 11011011011010000000000_{2}
   - exponent
     - =E= = 13
     - =Bias= = 127
     - =Exp= = 140 = 10001100_{2}
   - result
     - 0 10001100 11011011011010000000000

#+BEGIN_EXAMPLE

15213

 11101101101101
1.1101101101101 * 2^13

Significand
M    = 1.1101101101101
frac =   11011011011010000000000

Exponent
E    = 13
Bias = 127
Exp  = 140 = 10001100

Result
0 10001100 11011011011010000000000

#+END_EXAMPLE


** Denormalized Values

 - when exp = 000...0

 - exponent value: E = 1 - Bias  (*instead of E = 0 - Bias*)

 - significand coded with implied leading 0: M = 0.xxx...x_{2}
   - xxx...x: bits of frac field

 - exp = 000...0, frac = 000...0
   - represents zero value
   - +0 (positive 0) : 0 00000000 00000000000000000000000
   - -0 (negative 0) : 1 00000000 00000000000000000000000
 - exp = 000...0, frac \neq 000...0
   - numbers closest to 0.0
   - equispaced


** Special Values

 - when exp = 111...1

 - exp = 111...1, frac = 000...0
   - represents value \infty (infinity)
   - operation that overflows
   - both positive and negative
   - e.g. \( 1.0/0.0 = -1.0/-0.0 = +\infty, 1.0/-0.0 = -\infty \)

 - exp = 111...1, frac \neq 000...0
   - Not-a-Number (NaN)
   - representation case when no numeric value can be determined
   - e.g. \( \sqrt{-1}, \infty - \infty, \infty \times 0 \)


** Summary

#+ATTR_HTML: :width 500px
[[./res/floating_point_encoding.png]]

\[ (-1)^{s} M 2^{E} \]

| value type         | condition     | exponent       | significand |
|--------------------+---------------+----------------+-------------|
| normalized value   |               | E = Exp - Bias |             |
|--------------------+---------------+----------------+-------------|
| denormalized value |               | E = 1 - Bias   |             |
|--------------------+---------------+----------------+-------------|
| special value      | exp = 111...1 |                |             |
